# Module 4: Model Updates

## Goal

Fix validation issues and improve the auto-judging logic in the DrillClue model.

## Files to Modify

- `/app/models/drill_clue.rb`

---

## Issue 1: Method Name Collision

**CRITICAL**: The model has TWO `passed?` methods:
- One public (line 24-26) checking the enum
- One private (line 48-50) checking the response string

This creates a conflict!

### Solution: Rename Private Method

```ruby
# app/models/drill_clue.rb

private
  def set_result
    case true
    when response_matches_question?
      self.result = :correct
    when response_indicates_pass?  # RENAMED to avoid collision
      self.result = :pass
    else
      self.result = :incorrect
    end
  end

  def response_indicates_pass?
    response.blank? || response.strip.match?(/\Ap(?:ass)?\z/i) || no_buzz?
  end
```

**Why?** The public `passed?` method is generated by the enum and checks if `result == :pass`. The private method should have a different name to avoid confusion.

---

## Issue 2: Invalid Validation Option

**Problem**: Line 10 uses `except_on: :new` which is **not a valid Rails option**.

### Solution: Use `unless: :new_record?`

**Before:**
```ruby
validates :response_time,
  inclusion: {
    in: 0..JTrainer::MAX_RESPONSE_TIME,
    message: "must be between 0 and #{JTrainer::MAX_RESPONSE_TIME} seconds"
  },
  except_on: :new  # INVALID!
```

**After:**
```ruby
validates :response_time,
  inclusion: {
    in: 0..JTrainer::MAX_RESPONSE_TIME,
    message: "must be between 0 and #{JTrainer::MAX_RESPONSE_TIME} seconds"
  },
  unless: :new_record?  # CORRECT!
```

**Why?** Validations don't have an `except_on` option. Use `unless:` with a conditional method instead.

---

## Issue 3: Response Matching Logic

### Current Implementation

```ruby
# Current implementation (line 41)
def response_matches_question?
  Regexp.new(clue.question).match?(response)
end
```

**Problem**: Treats `clue.question` as a regex pattern, which may fail if it contains special regex characters like `(`, `)`, `[`, `]`, `.`, `*`, etc.

### Example Failure

If `clue.question = "What is C++?"`, this becomes a regex like `/What is C++?/`, which is invalid because `+` is a regex metacharacter.

### Improved Version

```ruby
# Improved version - handles Jeopardy! format
def response_matches_question?
  return false if response.blank?

  # Extract answer from "What is X?" format if present
  answer_text = clue.question.gsub(/\A(what|who|where|when|why) is\s+/i, '').gsub(/\??\z/, '').strip

  # Normalize both strings: downcase, remove punctuation, trim
  normalized_response = response.downcase.gsub(/[^a-z0-9\s]/, '').strip
  normalized_answer = answer_text.downcase.gsub(/[^a-z0-9\s]/, '').strip

  # Check if response contains the key answer terms
  normalized_answer.include?(normalized_response) ||
    normalized_response.include?(normalized_answer)
end
```

### Key Improvements

1. **Handles Jeopardy! Format**: Strips "What is", "Who is", etc. from the question
2. **Normalization**: Lowercases and removes punctuation
3. **Bidirectional Matching**: Checks if either string contains the other
4. **No Regex Parsing**: Treats clue.question as a string, not a regex

### Example

```ruby
clue.question = "What is the Jordan?"
response = "jordan"

# After normalization:
normalized_answer = "the jordan"
normalized_response = "jordan"

# Match: "the jordan".include?("jordan") => true
```

---

## Understanding Jeopardy! Format

In the Jeopardy! data format:
- **`clue.answer`** = "the Jordan" (what we SHOW users - the clue)
- **`clue.question`** = "What is the Jordan?" or just "the Jordan" (the correct response)

**Confusing?** Yes! This is because in the TV show:
- Host reads the "answer" (a statement)
- Contestants respond with the "question" (phrased as a question)

Example:
- **Clue shown to user**: "River mentioned most often in the Bible" (`clue.answer`)
- **Correct response**: "What is the Jordan?" (`clue.question`)

---

## Complete Updated Model

### Key Sections to Update

```ruby
# app/models/drill_clue.rb

class DrillClue < ApplicationRecord
  belongs_to :drill
  belongs_to :clue

  # Enum for result
  enum :result, { correct: -1, pass: 0, incorrect: 1 }

  # Validations
  validates :response_time,
    inclusion: {
      in: 0..JTrainer::MAX_RESPONSE_TIME,
      message: "must be between 0 and #{JTrainer::MAX_RESPONSE_TIME} seconds"
    },
    unless: :new_record?  # FIX: Use unless instead of except_on

  # Callbacks
  before_save :set_result
  after_save :update_counts!

  private

  def set_result
    case true
    when response_matches_question?
      self.result = :correct
    when response_indicates_pass?  # FIX: Renamed from passed?
      self.result = :pass
    else
      self.result = :incorrect
    end
  end

  def response_matches_question?
    return false if response.blank?

    # Extract answer from "What is X?" format if present
    answer_text = clue.question.gsub(/\A(what|who|where|when|why) is\s+/i, '').gsub(/\??\z/, '').strip

    # Normalize both strings: downcase, remove punctuation, trim
    normalized_response = response.downcase.gsub(/[^a-z0-9\s]/, '').strip
    normalized_answer = answer_text.downcase.gsub(/[^a-z0-9\s]/, '').strip

    # Check if response contains the key answer terms (bidirectional)
    normalized_answer.include?(normalized_response) ||
      normalized_response.include?(normalized_answer)
  end

  def response_indicates_pass?  # FIX: Renamed from passed?
    response.blank? || response.strip.match?(/\Ap(?:ass)?\z/i) || no_buzz?
  end

  def no_buzz?
    response_time.to_f > JTrainer::MAX_BUZZ_TIME
  end

  def update_counts!
    drill.reload
    # Existing callback logic...
  end
end
```

---

## Testing Checklist

- [ ] Test `response_matches_question?` with various inputs:
  - Exact match: "the Jordan" vs "the Jordan" → correct
  - Case insensitive: "jordan" vs "the Jordan" → correct
  - Partial match: "jordan" vs "the Jordan River" → correct
  - With punctuation: "c++" vs "What is C++?" → correct
  - Wrong answer: "nile" vs "the Jordan" → incorrect
- [ ] Test `response_indicates_pass?`:
  - Blank response → pass
  - "pass" → pass
  - "p" → pass
  - Any other text → not a pass
- [ ] Test enum methods still work:
  - `drill_clue.correct?` → true/false
  - `drill_clue.passed?` → true/false
  - `drill_clue.incorrect?` → true/false
- [ ] Test validation:
  - New record with no response_time → valid
  - Saved record with response_time > MAX_RESPONSE_TIME → invalid
- [ ] Test callback:
  - Saving drill_clue updates drill counts

---

## Future Enhancements (Out of MVP Scope)

### 1. Fuzzy Matching with Levenshtein Distance

```ruby
require 'levenshtein'

def response_matches_question?
  return false if response.blank?

  distance = Levenshtein.distance(normalized_response, normalized_answer)
  max_distance = [normalized_answer.length / 4, 2].max

  distance <= max_distance
end
```

### 2. User Override

Add a field to allow users to override auto-judged results:

```ruby
# Migration
add_column :drill_clues, :user_override, :integer

# Model
def final_result
  user_override || result
end
```

### 3. Partial Credit

```ruby
enum :result, { correct: 2, partial: 1, pass: 0, incorrect: -1 }

def response_matches_question?
  if exact_match?
    :correct
  elsif partial_match?
    :partial
  else
    false
  end
end
```

---

## Notes

- Keep existing callback logic intact (drill count updates)
- Existing enum methods (`correct?`, `passed?`, `incorrect?`) still work
- The normalization approach is simple but effective for MVP
- Can add more sophisticated matching (fuzzy, ML-based) later
